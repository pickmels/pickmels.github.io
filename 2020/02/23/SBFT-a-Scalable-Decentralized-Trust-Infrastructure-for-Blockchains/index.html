<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="SBFT:a Scalable Decentralized Trust Infrastructure for Blockchains"><meta name="keywords" content="论文笔记"><meta name="author" content="湛兮,undefined"><meta name="copyright" content="湛兮"><title>SBFT:a Scalable Decentralized Trust Infrastructure for Blockchains | 湛兮de小树洞</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#INTRODUCTION"><span class="toc-number">1.</span> <span class="toc-text">INTRODUCTION</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SBFT：a-Scalable-Decentralized-Trust-Infrastructure-for-Blockchains"><span class="toc-number">2.</span> <span class="toc-text">SBFT：a Scalable Decentralized Trust Infrastructure for Blockchains</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、From-PBFT-to-linear-PBFT"><span class="toc-number">2.1.</span> <span class="toc-text">1、From PBFT to linear PBFT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、adding-a-fast-path"><span class="toc-number">2.2.</span> <span class="toc-text">2、adding a fast path</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、reducing-client-communication-from-f-1-to-1"><span class="toc-number">2.3.</span> <span class="toc-text">3、reducing client communication from f+1 to 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、addding-redundant-servers-to-improve-resilience-and-performance"><span class="toc-number">2.4.</span> <span class="toc-text">4、addding redundant servers to improve resilience and performance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、Evaluating-SBFT’s-scalability"><span class="toc-number">2.5.</span> <span class="toc-text">5、Evaluating SBFT’s scalability</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SYSTEM-MODEL"><span class="toc-number">3.</span> <span class="toc-text">SYSTEM MODEL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MODERN-CRYPTOGRAPHY"><span class="toc-number">4.</span> <span class="toc-text">MODERN CRYPTOGRAPHY</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SERVICE-PROPERTIES"><span class="toc-number">5.</span> <span class="toc-text">SERVICE PROPERTIES</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、Generic-service"><span class="toc-number">5.1.</span> <span class="toc-text">1、Generic service</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、A-authenticated-key-value-store"><span class="toc-number">5.2.</span> <span class="toc-text">2、A authenticated key-value store</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、A-smart-contract-engine"><span class="toc-number">5.3.</span> <span class="toc-text">3、A smart contract engine</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SBFT-REPLICATION-PROTOCOL"><span class="toc-number">6.</span> <span class="toc-text">SBFT REPLICATION PROTOCOL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、SBFT在fast-path下的工作流程"><span class="toc-number">6.1.</span> <span class="toc-text">1、SBFT在fast path下的工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、The-Client"><span class="toc-number">6.2.</span> <span class="toc-text">2、The Client</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、The-Replicas"><span class="toc-number">6.3.</span> <span class="toc-text">3、The Replicas</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、fast-path-protocol"><span class="toc-number">6.4.</span> <span class="toc-text">4、fast path protocol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、Execution-and-Acknowledgement"><span class="toc-number">6.5.</span> <span class="toc-text">5、Execution and Acknowledgement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、Linear-PBFT"><span class="toc-number">6.6.</span> <span class="toc-text">6、Linear-PBFT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、Garbage-Collection-and-Checkpoint-Protocol"><span class="toc-number">6.7.</span> <span class="toc-text">7、Garbage Collection and Checkpoint Protocol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、View-Change-Protocol"><span class="toc-number">6.8.</span> <span class="toc-text">8、View Change Protocol</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/46594910?s=460&amp;v=4"></div><div class="author-info__name text-center">湛兮</div><div class="author-info__description text-center">Don't wait for luck!</div><div class="follow-button"><a href="https://github.com/pickmels" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://github.com" target="_blank">GitHub</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://hdqwalls.com/wallpapers/milky-way-5k-hd.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">湛兮de小树洞</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">SBFT:a Scalable Decentralized Trust Infrastructure for Blockchains</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-23</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4k</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>SBFT可以说是PBFT的扩展，它解决了扩展性(scalabillity)的问题，可以支持世界范围内的209个replicas（其中64个拜占庭错误replica）正常运行，并且吞吐量可以达到PBFT的两倍，延迟也更低。<br>//先写一下SBFT的论文总结吧，之后再更PBFT的。</p>
<a id="more"></a>
<h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>中心化提供了好的性能，但存在一系列问题，比特币和以太坊的成功说明了去中心化巨大的潜在价值。但是研究表明，比特币和以太坊并没有先前想的那么去中心化，前20%的矿池控制了超过90%的算力。这一研究说明了BFT算法应用于区块链的可行性（由于PoW过于消耗资源），也促使了BFT相关算法的研究。近年来BFT相关算法有替换掉PoW或者与PoW组合应用于区块链的趋势。</p>
<h1 id="SBFT：a-Scalable-Decentralized-Trust-Infrastructure-for-Blockchains"><a href="#SBFT：a-Scalable-Decentralized-Trust-Infrastructure-for-Blockchains" class="headerlink" title="SBFT：a Scalable Decentralized Trust Infrastructure for Blockchains"></a>SBFT：a Scalable Decentralized Trust Infrastructure for Blockchains</h1><p>SBFT为了做到这些性能上的提升，基于PBFT增加了四点设计上的改进：</p>
<p>（1）going from PBFT to linear PBFT<br>（2）adding a fast path<br>（3）using cryptography to allow a single message acknowledgement<br>（4）adding redundant servers to improve resilience and performance</p>
<h2 id="1、From-PBFT-to-linear-PBFT"><a href="#1、From-PBFT-to-linear-PBFT" class="headerlink" title="1、From PBFT to linear PBFT"></a>1、From PBFT to linear PBFT</h2><p>很多之前的系统都使用了多对多(all-to-all)的消息模式来提交一个确认区块，SBFT提出了一个使用收集器(collector)的线性通信模式。这种模式下不再将消息发给每一个replica，而是发给collector，然后再由collector广播给所有replicas。同时通过使用门限签名(threshold signatures)可以将消息长度从线性降低到常数。</p>
<p>//Zyzzyva也使用了collector，但是将collector的职责放到了client，而SBFT将collector的职责放到了replica。</p>
<h2 id="2、adding-a-fast-path"><a href="#2、adding-a-fast-path" class="headerlink" title="2、adding a fast path"></a>2、adding a fast path</h2><p>当所有replica都没有错误并且是同步(synchronous)时，SBFT允许使用快速共识机制。</p>
<p>SBFT实现了第一个正确且实用的双模式view change，可以在快速共识和正常共识之间无缝切换。</p>
<h2 id="3、reducing-client-communication-from-f-1-to-1"><a href="#3、reducing-client-communication-from-f-1-to-1" class="headerlink" title="3、reducing client communication from f+1 to 1"></a>3、reducing client communication from f+1 to 1</h2><p>在之前所有的解决方案中，client都需要收到f+1来自replicas的一致的reply才可以确认自己发出的request是否被执行。当client和replicas增多时，通信负载压力会增大。在SBFT中，正常情况下，每一个client只需要收到一个reply就足够了，这使得SBFT可以支持非常多的瘦客户端。</p>
<p>SBFT通过使用execution collector来做到这一点，execution collector收集replicas的execution threshold signatures并将其组合起来发送给client。像公链(比如比特币和以太坊)一样，SBFT也使用了默克尔树(merkle tree)来认证从某一个replica读取的信息。</p>
<p>SBFT使用了BLS签名，相比RSA签名，BLS只需要33个bytes就可以达到2048个bit(256个bytes)的RSA签名的安全性。</p>
<p>//八倍还是很可观的，当然BLS还有很多其他很有用的性质.</p>
<h2 id="4、addding-redundant-servers-to-improve-resilience-and-performance"><a href="#4、addding-redundant-servers-to-improve-resilience-and-performance" class="headerlink" title="4、addding redundant servers to improve resilience and performance"></a>4、addding redundant servers to improve resilience and performance</h2><p>当有f个拜占庭节点时，SBFT是安全的。不过只有当所有的节点都没有错误且系统是同步的时候才可以使用标准的快速共识，因此即使一个节点的故障都会使系统从fast path切换到slow path。</p>
<p>SBFT借鉴了single-shot consensus algorithm中提出的理论，使得fast path可以在3f+2c+1个replicas的系统中容忍c个故障replicas（这里，c是一个很小的常量）。</p>
<h2 id="5、Evaluating-SBFT’s-scalability"><a href="#5、Evaluating-SBFT’s-scalability" class="headerlink" title="5、Evaluating SBFT’s scalability"></a>5、Evaluating SBFT’s scalability</h2><p>由于目前没有什么可以和SBFT比的，于是作者改进了已有的PBFT算法，称之为scale optimized PBFT，作为比较对象。总之就是效果很好就是了。</p>
<h1 id="SYSTEM-MODEL"><a href="#SYSTEM-MODEL" class="headerlink" title="SYSTEM MODEL"></a>SYSTEM MODEL</h1><p>论文中讨论了三种模型：</p>
<p>（1）标准异步模式：敌人最多控制网络中的f个拜占庭节点、可以造成整个网络的延迟。SBFT可以保证safety，也就是任何两个replicas都会按同样的顺序执行同一个block。</p>
<p>（2）同步模型：敌人最多控制网络中的f个拜占庭节点。SBFT可以保证liveness，也就是client的request都会得到reply。</p>
<p>（3）一般模式：敌人最多控制网络中的c个慢的或者崩溃的节点。SBFT可以保证linearity，就是说每提交一个block只需要固定数量的消息（大概）。</p>
<h1 id="MODERN-CRYPTOGRAPHY"><a href="#MODERN-CRYPTOGRAPHY" class="headerlink" title="MODERN CRYPTOGRAPHY"></a>MODERN CRYPTOGRAPHY</h1><p>SBFT还使用了<strong>门限签名(threshold signature)</strong>，对于n个replicas，只需要replicas的一个子集对block进行签名就可以验证。即子集中的replica分别使用自己的私钥签名之后再组合起来，最后可以只验证一次就可以了。</p>
<p>SBFT使用了比RSA签名算法更短更快的<strong>BLS签名算法</strong>，BLS基于椭圆曲线，有很多实用的性质，比如支持批量验证签名。</p>
<h1 id="SERVICE-PROPERTIES"><a href="#SERVICE-PROPERTIES" class="headerlink" title="SERVICE PROPERTIES"></a>SERVICE PROPERTIES</h1><p>SBFT提供了一个可扩展的通用复制服务的容错实现（也就是状态机复制服务），在这之上使用默克尔树实现了一个可认证的键值存储，又实现了可以执行EVM字节码的智能合约层。</p>
<h2 id="1、Generic-service"><a href="#1、Generic-service" class="headerlink" title="1、Generic service"></a>1、Generic service</h2><p>实现了确定的带状态的复制服务、确定的操作、只读的查询接口。</p>
<p>（1）val=execute(D,o)：根据操作o修改状态D，并返回val.</p>
<p>（2）val=query(D,q)：返回状态D下的查询q，不修改D.</p>
<p>（3）服务的状态由离散的block改变，每一个block包含一些request，论文中使用Dj表示执行完序号为j的block的状态，使用reqj表示序号为j的block包含的request.</p>
<h2 id="2、A-authenticated-key-value-store"><a href="#2、A-authenticated-key-value-store" class="headerlink" title="2、A authenticated key-value store"></a>2、A authenticated key-value store</h2><p>为了支持client高效地认证来自某个replica的消息，在键值存储中设计了一些数据认证接口。</p>
<p>（1）d=digest(D)：返回状态为D的默克尔哈希根的值作为哈希值。</p>
<p>（2）P=proof(o,l,s,D,val)：返回序号为s的block中第l个操作o在状态D下(或者执行完后状态变为D)执行后的结果val的证明。</p>
<p>（3）P=proof(q,s,D,val)： 和（2）一样，不过是查询q的证明。</p>
<p>（4）verify(d,o,val,s,l,P)：如果序号为s的block中第l个操作o执行完毕后状态D的签名变成d，P是这一操作的有效证明，返回True。</p>
<p>（5）verify(d,q,val,s,P)：同4。</p>
<h2 id="3、A-smart-contract-engine"><a href="#3、A-smart-contract-engine" class="headerlink" title="3、A smart contract engine"></a>3、A smart contract engine</h2><p>这一层是为了以后方便集成其它智能合约语言。目前的EVM layer实现了两个主要组件：</p>
<p>（1）EVM的实现；</p>
<p>（2）实现一个接口，完成对以太坊两个主要交易类型（创建合约&amp;&amp;执行合约）的建模。</p>
<h1 id="SBFT-REPLICATION-PROTOCOL"><a href="#SBFT-REPLICATION-PROTOCOL" class="headerlink" title="SBFT REPLICATION PROTOCOL"></a>SBFT REPLICATION PROTOCOL</h1><p>整个系统有3f+2c+1个replica，编号从1到3f+2c+1。使用了三个门限签名：<br>（1）σ with threshold (3f+c+1)<br>（2）τ with threshold (2f+c+1)<br>（3）π with threshold (f+1)</p>
<p>和PBFT一样使用了view change协议，每一个view有一个primary，其它repplica是backups。与PBFT不同的是，这些backups还拥有其他身份，Commit collectors和Execution collectors。每一个view中都会有c+1个Commit collectors和Execution collectors用来收集并组合门限签名和传播结果签名。为了实现liveness，至少需要一个collector，论文中在fast path情况下用了c+1个collector实现冗余。</p>
<p>Commit collectors的作用是收集提交消息，并将组合的签名发送回副本以确认提交。 Execution collectors的作用是收集执行消息，并将组合的签名发送回副本和客户端，以便它们都具有执行其请求的证书。</p>
<h2 id="1、SBFT在fast-path下的工作流程"><a href="#1、SBFT在fast-path下的工作流程" class="headerlink" title="1、SBFT在fast path下的工作流程"></a>1、SBFT在fast path下的工作流程</h2><p><img src="/2020/02/23/SBFT-a-Scalable-Decentralized-Trust-Infrastructure-for-Blockchains/001.png" alt=""></p>
<p>（1）client向primary发送request<br>（2）primary收集request，将其打包成block，并作为pre-prepare message转发给其他replicas<br>（3）replicas对收到的pre-prepare message使用σ(3f+c+1)签名，然后将签名消息发给C-collectors.<br>（4）每一个C-collector收集签名，为该block创建一个full-commit-proof消息发给replicas</p>
<p>一旦replica收到full-commit-proof消息，它就commit这个block，然后开始执行execution protocol：</p>
<p>（1）当replica执行完提交的block之前的blocks，它执行这个block中的request，并使用π(f+1)进行签名，然后发送sign-state message给E-collectors<br>（2）E-collector收集签名，并为该block创建一个full-execute-proof ，然后告诉replicas和client当前状态是持久的并且操作已经被执行。</p>
<p>SBFT通过对给一个decision block选不同的E-collectors和C-collectors来实现负载均衡。</p>
<h2 id="2、The-Client"><a href="#2、The-Client" class="headerlink" title="2、The Client"></a>2、The Client</h2><p>client k 通过发送⟨“request”,o,t,k⟩消息给primary，primary再转发给backups，开始共识。</p>
<p>先前的系统中client需要等待f+1个replica才完成确认，SBFT中只需要一个<br>⟨“execute−ack”,s,val,o,π(d),proof(o,l,s,D,val)⟩消息就可以确认。如果client等待超时，就会将该request发给所有的replicas。</p>
<h2 id="3、The-Replicas"><a href="#3、The-Replicas" class="headerlink" title="3、The Replicas"></a>3、The Replicas</h2><p>replica的状态包含一个记录所有消息的log，状态还包含了视图编号、上一个稳定的序号(last stable sequence)、执行完所有commited requests后服务的状态D。还使用了一个固定值win限制超前太多的block。</p>
<p>有的replicas还担任C-collectors或则E-collector，执行特殊的任务。</p>
<h2 id="4、fast-path-protocol"><a href="#4、fast-path-protocol" class="headerlink" title="4、fast path protocol"></a>4、fast path protocol</h2><p>fast path protocol是执行的默认模式，可以在不超过c个crashed/slow replicas的同步环境下正常运行。</p>
<p>为了commit一个新的block，primary开始执行一个三阶段的协议:pre-prepare、sign-share、commit-proof.</p>
<p><strong>（1）pre-prepare阶段：</strong></p>
<p>primary收到来自client k的⟨“request”,o,t,k⟩（如果操作o通过静态服务认证和访问控制规则就接受），当收到至少b个(b≥batch)client发来的request（或者超时）后，将这些request打包到集合r=(r1,r2,…,rb).然后广播⟨“pre−prepare”,s,v,r⟩<br>⟨“pre−prepare”,s,v,r⟩给所有的replicas。其中s是当前的序号，v是视图号。batch这个参数是通过自适应算法设置的。</p>
<p><strong>（2）Sign-share阶段：</strong></p>
<p>replica收到⟨“pre−prepare”,s,v,r⟩消息后，进行检查，满足条件（具体条件参考论文）就接受。然后计算h=H(s∣∣v∣∣r)，其中H是一个加密哈希函数（比如SHA256），接着对h进行签名σi(h)，最后发送⟨“sign−share”,s,v,σi(h)⟩消息给那些C-collectors &lt;C-collectors(s, v)&gt;.</p>
<p><strong>（3）Commit-proof阶段：</strong></p>
<p>C-collectors(s,v)收到⟨“sign−share”,s,v,σi(h)⟩后，进行检查，当接受3f+c+1个不同的sign-share消息时，将这些消息组合成一个大的签名σ(h)，然后发送<br>⟨“full−commit−proof”,s,v,σ(h)⟩给其他replicas。</p>
<p><strong>（4）Commit trigger阶段：</strong><br>replica收到⟨“full−commit−proof”,s,v,σ(h)⟩消息后，检查，确认接受，然后commit r（r是序号为s的请求）。</p>
<h2 id="5、Execution-and-Acknowledgement"><a href="#5、Execution-and-Acknowledgement" class="headerlink" title="5、Execution and Acknowledgement"></a>5、Execution and Acknowledgement</h2><p>与先前的其他算法主要的不同在于使用了<strong>门限签名</strong>。一旦replica收到committed的block，就启动一个两阶段的协议：sign-state、execute-proof.</p>
<p><strong>（1）Execute trigger and sign state：</strong></p>
<p>当收到committed的block（序号为s）后，replica_i执行request将状态从Ds−1更新到Ds。然后更新状态摘要d=digest(Dx)，签名πi(d)，最后发送⟨“sign−state”,s,πi(d)⟩消息给集合E-collectors(s)。</p>
<p><strong>（2）Execute-proof：</strong></p>
<p>E-collector收集⟨“sign−state”,s,πi(d)⟩消息并验证签名，当收到f+1个时，将其租着成一个签名π(d)，发送⟨“full−execute−proof”,s,π(d)⟩消息给所有的replica，replicas检查签名决定是否接受。</p>
<p>然后E-collector对每一个request o∈r，发给client一个<br>⟨“execute−ack”,s,l,val,o,π(d),proof(o,l,s,D,val)⟩，其中是o的返回值。client接收<br>⟨“execute−ack”,s,l,val,o,π(d),P⟩消息后，检查π(d)是否有效并且verify(d,o,val,s,l,P)是否为真，确认有效后client标记o已执行，将val设置为返回值。如果client超时就重发该request，进行正常共识。</p>
<h2 id="6、Linear-PBFT"><a href="#6、Linear-PBFT" class="headerlink" title="6、Linear-PBFT"></a>6、Linear-PBFT</h2><p>当fast path无法达成共识时，就使用Linear-PBFT。Linear-PBFT是对PBFT的改编，使用了<strong>门限签名和线性通信</strong>。</p>
<p><strong>（1）Sign-share：</strong></p>
<p>需要包含两个签名，σi(h)(for fast path)和τi(h)(for Linear PBFT path)</p>
<p><strong>（2）Trigger for Linear-PBFT：</strong></p>
<p>根据过去的流量情况采用自适应算法确定一个等待时间，如果超时就切换到Linear-PBFT。C-collector收集签名，创建τ(h)，如果超时，就发送⟨“prepare”,s,v,τ(h)⟩给所有replicas。</p>
<p><strong>（3）Prepare：</strong></p>
<p>replica收到⟨“prepare”,s,v,τ(h)⟩消息并进行检查，如果通过检查就发送⟨“commit”,s,v,τi(τ(h))⟩给所有C-collectors。</p>
<p><strong>（4）PBFT commit-proof：</strong></p>
<p>C-collectors收集足够的签名来创建⟨“full−commit−proof−slow”,s,v,τ(τ(h))⟩消息，发给所有replicas。</p>
<p><strong>（5）Commit trigger for Linear-PBFT：</strong></p>
<p>如果replica收到⟨“full−commit−proof−slow”,s,v,τ(τ(h))⟩和⟨“pre−prepare”,s,v,r,h⟩<br>消息，验证通过h=H(s∣∣v∣∣r)，然后就commit r(r是block s 包含的request)。</p>
<h2 id="7、Garbage-Collection-and-Checkpoint-Protocol"><a href="#7、Garbage-Collection-and-Checkpoint-Protocol" class="headerlink" title="7、Garbage Collection and Checkpoint Protocol"></a>7、Garbage Collection and Checkpoint Protocol</h2><p>block s 有三种状态：</p>
<p>（1）Committed：至少一个正常的replica commit了该block</p>
<p>（2）Executed：至少一个正常的replica commit完了1到s的所有block</p>
<p>（3）Stable：至少f+1个正常的replica execute了该block</p>
<p>当一个block状态时Stable时，可以收集先前的block。像PBFT中一样，每隔一定周期(win/2)进行一次checkpoint protocol，更新ls (the last stable sequence number).</p>
<h2 id="8、View-Change-Protocol"><a href="#8、View-Change-Protocol" class="headerlink" title="8、View Change Protocol"></a>8、View Change Protocol</h2><p>SBFT中有两种commit模式，Fast-path和Linear-PBFT。</p>
<p>先前的方案需要显式地指出使用哪一种模式，SBFT提出了新的View Change Protocol，支持同时运行两种模式，并无缝切换。</p>
<p><strong>（1）View change trigger:</strong></p>
<p>当计时器超时或收到其主节点有故障的证据（通过公开可验证的矛盾或f + 1个副本抱怨）时，replica会触发视图更改。</p>
<p><strong>（2）View-change 阶段:</strong><br><img src="/2020/02/23/SBFT-a-Scalable-Decentralized-Trust-Infrastructure-for-Blockchains/002.png" alt=""></p>
<p><strong>（3）New-view 阶段:</strong> </p>
<p>新主节点从replicas收集2f+2c+1个view-change消息，通过发送一个消息（2f+2c+1个view-change消息的集合体）来初始化一个新view.</p>
<p><strong>（4）Accepting a New-view:</strong> </p>
<p>当节点收到集合I（ 2 f + 2c + 1视图更改消息）时，它一一处理从ls（所有视图更改消息中的最高有效稳定序列号）到ls+win的slots。对于每个这样的slot，根据以下算法，节点要么决定可以提交值，要么将其用作新的主节点的pre-prepare消息。</p>
<p>如果节点收到σ(⋆)或τ(τ(⋆)))，则由节点决定。否则，它采用安全值(参见论文)。安全值y是由最高视图而得到的值，对于该最高视图，可能存在在先前视图中可能提交的潜在值。要定义此视图，需要仔细定义两个提交路径中的每一个都具有值的最高视图，然后在这两个路径之间采用最高视图。如果没有需要采用的值，我们将使用特殊的无操作操作来填充序列。</p>
<p><img src="/2020/02/23/SBFT-a-Scalable-Decentralized-Trust-Infrastructure-for-Blockchains/005.png" alt=""></p>
<p>如果FX包含σ(h)或LX包含τ(τ(h))，则让y为h并在知道消息后提交。否则：</p>
<p><img src="/2020/02/23/SBFT-a-Scalable-Decentralized-Trust-Infrastructure-for-Blockchains/003.png" alt=""></p>
<p><strong>（5）Efficient view change via pipelining:</strong></p>
<p>SBFT允许在序列号&lt;x的pre-prepare信息到达之前提交序列号x。这使SBFT具有高度的并行性。</p>
<p>像PBFT一样，在视图更改期间，SBFT需要为ls和ls + win之间的每个序列号建议一个值。另一种方法是仅在所有≤x序列号的所有pre-prepare消息到达后，并且x的哈希值代表整个历史记录（即，$h_x=H(r || s || v || h_{x-1})$）之后，才提交序列号x。这意味着，当主节点提交序列号x时，它将在同一决策中隐式提交所有≤x的序列号。</p>
<p>通过这些更改，我们可以进行更有效的view-change。对于新的主节点来说，无需为从ls到ls + win的每个序列号发送带有证明的pre-prepare的值，只需从每个副本中收集两对信息就足够了。</p>
<p><img src="/2020/02/23/SBFT-a-Scalable-Decentralized-Trust-Infrastructure-for-Blockchains/004.png" alt=""></p>
<p>和之前一样，主节点收集2f+2c+1这样的消息，并从(v,h)和($v’,h’$)中选择最高的视图（如果有平局，则首选(v,h)）。</p>
<p>这种视图更改的优点是，无论窗口大小如何，仅发送两个值。</p>
<hr>
<p>//todo：safety和liveness的证明<br>实现：<a href="https://github.com/vmware/concord-bft" target="_blank" rel="noopener">https://github.com/vmware/concord-bft</a></p>
<hr>
<p>Anyway，Fighting is right!</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">湛兮</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/02/23/SBFT-a-Scalable-Decentralized-Trust-Infrastructure-for-Blockchains/">http://yoursite.com/2020/02/23/SBFT-a-Scalable-Decentralized-Trust-Infrastructure-for-Blockchains/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">湛兮de小树洞</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/论文笔记/">论文笔记</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2019/12/25/3-Dijkstra-Algorithm/"><span>3-Dijkstra Algorithm</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By 湛兮</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>